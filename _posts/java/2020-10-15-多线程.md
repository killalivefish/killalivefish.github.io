---
layout: post
title: "Java多线程" 
date: 2020-10-15 20:00:00
author: Hubo
categories: [Java基础]
tags: [Java基础]
---



用户线程 

守护线程 Thread.setDaemon(true);



继承Thread ---java单继承 ---不好

实现Runable接口 run()--不影响继承---没有返回值---new Thread(task).start();

实现Callable接口 call()--不影响继承---可以有返回值--new Thread(new FutureTask<>(task)).start();



内部锁（监视锁）

独占锁 lock



无状态对象是线程安全的

竞态条件：	基于一种可能失效的观察结果来做出判断---先检查后执行

存在竞态条件且执行时序错误的时候，会导致代码出现错误

以原子的方式执行一些操作，确保一系列操作中不会有别的操作影响

线程安全类--线程安全变量--AcomicLong



加锁

同步方法 --相当于加了互斥锁

同步代码块



join()

sleep()线程进入沉睡，时间到后自动唤醒--持有锁--阻塞状态

yeild()--就绪状态

wait()线程进入沉睡，直到notify或notifyAll（single()/singleAll()）--释放锁 注：waitb和notify必须在同步代码块中使用

interrupt()打断进程



新建

就绪

阻塞

死亡



死锁条件：互斥条件，请求并持有，不可剥夺，环路等待



ThreadLocal



内存不可见问题：

​	主内存 

​	线程内存

synchronized:线程内存中的变量清除，使用主内存中的变量数据，保证了可见性和原子性

volatile:线程在写入变量时直接刷到主内存，只保证了可见性不保证原子性

原子性操作：一系列操作要么全部执行，要么全部不执行；

CAS：





锁：

悲观锁：在数据处理前，加锁

乐观锁：在提交时才加锁



公平锁：B请求该锁，A释放锁后，B、C都请求获取锁，B会先获取到锁

非公平锁：B、C随机获取



独占锁：单线程持有

非独占锁：多个线程可以持有



可重入锁：已经获取到锁的类，还可以在重新获取到锁，jvm中计数器



自旋锁：不阻塞，反复请求10次



unsafe类：