---
title: 'redis'
author: 'Hubo'
---



# Redis



## 数据类型

String

list

set

sortSet

hash

gis

## 事务

原子性

隔离性

持久性

一致性

redis不支持回滚

## Redis事务

**MULTI，EXEC** ，multi后执行的命令不出错的话最后exec整体执行

## 缓存穿透

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。 ---https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all?id=_7-redis-%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e8%af%a6%e8%a7%a3

### 解决方法

1.对请求的数据进行缓存并设置存储时间，时间设置短点

2.布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。 

​	实现原理：通过key值计算出hash值，通过hash值计算数组存数据的对应位置，将对应位置的值设为1

## 缓存雪崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

### 解决方法

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。