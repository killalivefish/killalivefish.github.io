<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-03-27T10:06:18+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">My blog</title><subtitle>My blog.</subtitle><entry><title type="html">多层面的负载均衡</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%A7%8D%E5%B1%82%E9%9D%A2%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="alternate" type="text/html" title="多层面的负载均衡" /><published>2025-03-27T07:00:36+08:00</published><updated>2025-03-27T07:00:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%A7%8D%E5%B1%82%E9%9D%A2%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%A7%8D%E5%B1%82%E9%9D%A2%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"><![CDATA[<ol>
  <li><strong>入口层（Nginx）</strong>：
    <ul>
      <li>配置反向代理到Spring Cloud Gateway集群，实现高可用。</li>
      <li>设置负载均衡策略（如轮询、IP哈希）。</li>
      <li>配置SSL、静态文件服务、全局白名单/IP限制、压缩等。</li>
    </ul>
  </li>
  <li><strong>API网关（Spring Cloud Gateway）</strong>：
    <ul>
      <li>集成服务发现（Eureka/Nacos），动态路由到后端服务。</li>
      <li>配置全局过滤器（认证、日志、请求头修改）。</li>
      <li>结合Sentinel实现网关层限流。</li>
    </ul>
  </li>
  <li><strong>服务发现（Eureka/Nacos）</strong>：
    <ul>
      <li>服务注册与健康检查。</li>
      <li>客户端负载均衡的基础，服务消费者通过服务名调用。</li>
    </ul>
  </li>
  <li><strong>客户端负载均衡（OpenFeign + Ribbon/LoadBalancer）</strong>：
    <ul>
      <li>OpenFeign声明服务接口，自动处理服务发现和负载均衡。</li>
      <li>配置重试机制、超时时间、负载均衡策略（轮询、随机等）。</li>
    </ul>
  </li>
  <li><strong>细粒度流量控制（Sentinel）</strong>：
    <ul>
      <li>在服务层面配置流控规则（QPS、线程数、熔断降级）。</li>
      <li>结合OpenFeign实现熔断降级（如Fallback类）。</li>
      <li>网关层集成Sentinel进行全局流控。</li>
    </ul>
  </li>
</ol>

<p>需要注意的协同点：</p>
<ul>
  <li>Nginx和Spring Cloud Gateway的分工：Nginx处理外部流量，SSL终止，静态资源；Gateway处理动态路由和微服务相关的过滤。</li>
  <li>服务发现组件需要与客户端负载均衡（如OpenFeign）配合，确保实例列表的动态更新。</li>
  <li>Sentinel的规则需要根据实际业务需求配置，避免过度限制。</li>
</ul>

<p>一、组件分工与协作架构
|组件	|层级	|核心职责|
| —- | —- | —- |
|Nginx|	入口层|	反向代理、SSL终止、静态资源服务、全局IP白名单、粗粒度负载均衡（如轮询）|
|Spring Cloud Gateway|	网关层	|动态路由、鉴权、限流、熔断、服务发现集成（如Nacos/Eureka）|
|Eureka/Nacos| 服务发现层|	服务注册与发现、健康检查、提供实例列表给客户端负载均衡组件|
|OpenFeign|	服务间调用|	声明式HTTP客户端，集成客户端负载均衡（Ribbon/LoadBalancer）和重试|机制|
|Sentinel|	流量治理层|	细粒度流控（QPS/线程数）、熔断降级、热点参数限流、系统自适应保护|</p>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[Nginx、Gateway、Sentinel、LoadBalance...有这么多带有负载均衡的模块，项目中应该如何使用]]></summary></entry><entry><title type="html">OpenFeign的使用</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/OpenFeign/" rel="alternate" type="text/html" title="OpenFeign的使用" /><published>2025-03-27T06:27:36+08:00</published><updated>2025-03-27T06:27:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/OpenFeign</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/OpenFeign/"><![CDATA[<h1 id="feign的主要功能">Feign的主要功能：</h1>
<p>声明式的跨服务的接口调用,支持Eureka、Nacos等注册中心。
新版中默认使用spring-cloud的loadBalanced注解，自动实现负载均衡。
老版本使用Ribbon。</p>

<h1 id="如何使用">如何使用：</h1>
<p>现在有两个微服务一个order-service,一个goods-service。order-service调用goods-service的接口，那么在order-service中引入goods-service的依赖，然后通过@FeignClient注解声明一个接口，接口中的方法就是调用goods-service的接口。</p>
<ol>
  <li>引入依赖</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@SpringBootApplication</span>
  <span class="nd">@EnableDiscoveryClient</span>
  <span class="nd">@EnableFeignClients</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderServiceApplication</span> <span class="o">{</span>
      <span class="nd">@Bean</span>
      <span class="nd">@LoadBalanced</span>
      <span class="nc">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">RestTemplate</span><span class="o">();</span>
      <span class="o">}</span>
      
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">OrderServiceApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
      <span class="o">}</span>
      
  <span class="o">}</span>
</code></pre></div></div>

<ol>
  <li>创建一个接口
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nd">@FeignClient</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"goods-service"</span><span class="o">,</span> <span class="n">fallback</span> <span class="o">=</span> <span class="nc">Fallback</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">configuration</span> <span class="o">=</span> <span class="nc">FeignConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GoodsApi</span> <span class="o">{</span>
   <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/goods/reduceStock"</span><span class="o">)</span>
   <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">reduceStock</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>controller中调用接口
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nd">@RestController</span>
   <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/order"</span><span class="o">)</span>
   <span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">OrderController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
      
  <span class="nd">@Autowired</span>
  <span class="nc">GoodsApi</span> <span class="nc">GoodsApi</span><span class="o">;</span>
       
  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/orderPayment"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">orderPayment</span><span class="o">(){</span>
      <span class="nc">Integer</span> <span class="n">result1</span> <span class="o">=</span> <span class="nc">GoodsApi</span><span class="o">.</span><span class="na">reduceStock</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">result1</span><span class="o">;</span>
  <span class="o">}</span>
   <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="如何在调用失败后执行回调函数">如何在调用失败后执行回调函数</h2>
<ol>
  <li>需要在@FeignClient注解中声明fallback要使用的类
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FeignClient</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"goods-service"</span><span class="o">,</span> <span class="n">fallback</span> <span class="o">=</span> <span class="nc">Fallback</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>定义Fallback类
2.1 Fallback类实现FallbackFactory接口
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegralFallback</span> <span class="kd">implements</span> <span class="nc">IntegralApi</span><span class="o">{</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="no">LOGGER</span><span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">IntegralFallback</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">addIntegral</span><span class="o">()</span> <span class="o">{</span>
       <span class="no">LOGGER</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"addIntegral failed!!"</span><span class="o">);</span>
       <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoFallbackAvailableException</span><span class="o">(</span><span class="s">"Boom!"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">());</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegralFallbackFactory</span> <span class="kd">implements</span>  <span class="nc">FallbackFactory</span><span class="o">&lt;</span><span class="nc">IntegralFallback</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">IntegralFallback</span> <span class="nf">create</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">IntegralFallback</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>2.2 Fallback类实现@FeignClient修饰的类</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fallback</span> <span class="kd">implements</span> <span class="nc">GoodsApi</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="no">LOGGER</span><span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Fallback</span><span class="o">.</span> <span class="kd">class</span><span class="err">);</span>
    <span class="err">@</span><span class="nc">Override</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">reduceStock</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">LOGGER</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"reduceStock failed!!"</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="如何覆盖默认配置">如何覆盖默认配置</h1>
<p>在@FeignClient注解中声明configuration属性，指定配置类。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FeignClient</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"goods-service"</span><span class="o">,</span> <span class="n">configuration</span> <span class="o">=</span> <span class="nc">FeignConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<h1 id="如何设置重试">如何设置重试</h1>
<p>老版本需要设置Ribbon的重试和指定重试策略。
新版本中需要在在FeignConfig中声明Retryer属性。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">feign.Retryer</span><span class="o">;</span>

<span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">Retryer</span> <span class="nf">feignRetryer</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 参数：间隔时间(ms)、最大间隔时间、最大尝试次数（包含首次调用）</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Retryer</span><span class="o">.</span><span class="na">Default</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">1000</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="如何设置重试策略">如何设置重试策略</h1>
<p>新版本设置LoadBalancerClient的负载均衡策略。
老版本在Ribbon中设置重试策略。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 负载均衡策略（Spring Cloud LoadBalancer）</span>
<span class="nd">@Configuration</span>
<span class="nd">@LoadBalancerClient</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order-service"</span><span class="o">,</span> <span class="n">configuration</span> <span class="o">=</span> <span class="nc">CustomLoadBalancerConfig</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomLoadBalancerConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ReactorLoadBalancer</span><span class="o">&lt;</span><span class="nc">ServiceInstance</span><span class="o">&gt;</span> <span class="nf">randomLoadBalancer</span><span class="o">(...)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">RandomLoadBalancer</span><span class="o">(...);</span> <span class="c1">// 随机策略</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[记录OpenFeign的设计、实现和应用]]></summary></entry><entry><title type="html">SpringBean的加载和实现</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBean/" rel="alternate" type="text/html" title="SpringBean的加载和实现" /><published>2025-03-25T18:41:36+08:00</published><updated>2025-03-25T18:41:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBean</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBean/"><![CDATA[<h1 id="bean的容器ioc">Bean的容器（IoC）：</h1>
<p>ApplicationContext、BeanFactory、WebApplicationContext</p>
<h1 id="bean的命名">Bean的命名</h1>
<h1 id="bean的实例化">Bean的实例化</h1>
<ol>
  <li>构造函数</li>
  <li>工厂方法
    <h1 id="依赖注入di">依赖注入（DI）</h1>
  </li>
  <li>构造函数注入</li>
  <li>setter方法注入</li>
</ol>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[SpringBean的加载和实现]]></summary></entry><entry><title type="html">SpringBoot自动加载机制</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBoot%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="alternate" type="text/html" title="SpringBoot自动加载机制" /><published>2025-03-25T18:41:36+08:00</published><updated>2025-03-25T18:41:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBoot%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBoot%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"><![CDATA[<p>官方文档：https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/features.html#features.developing-auto-configuration</p>
<ol>
  <li>定义<code class="language-plaintext highlighter-rouge">AutoConfiguration</code>类</li>
  <li>定义<code class="language-plaintext highlighter-rouge">Configuration</code>类</li>
  <li>定义<code class="language-plaintext highlighter-rouge">KafkaProperties</code>类
SpringBoot自动加载机制的实现主要由下面这些注解实现
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({RestTemplate.class})
@ConditionalOnBean({LoadBalancerClient.class})
@EnableConfigurationProperties({LoadBalancerClientsProperties.class})
@ConfigurationProperties(“spring.cloud.loadbalancer”)</li>
</ol>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[SpringBoot自动加载机制的实现]]></summary></entry><entry><title type="html">Eureka设计与实现</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/Eureka/" rel="alternate" type="text/html" title="Eureka设计与实现" /><published>2025-03-25T07:00:36+08:00</published><updated>2025-03-25T07:00:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/Eureka</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/Eureka/"><![CDATA[<h1 id="eureka的主要功能">Eureka的主要功能：</h1>
<p>服务的注册和发现</p>

<h1 id="eureka的实现这些功能的主要途径">Eureka的实现这些功能的主要途径：</h1>
<h2 id="对于eureka-server">对于Eureka server</h2>
<ol>
  <li>需要有一个内存型的服务信息注册表</li>
  <li>对client提供可以接收服务注册表的接口</li>
  <li>对client提供注册、续租、取消的接口</li>
</ol>

<h2 id="对于eureka-client">对于Eureka client</h2>
<ol>
  <li>配置server对应的地址</li>
  <li>请求server实现服务的注册、续租、取消</li>
  <li>心跳机制向服务更新租约</li>
  <li>请求服务信息，保存在本地缓存并更新服务信息</li>
</ol>

<blockquote>
  <p>除此之外Eureka还会对服务按照zone、region进行划分，可以显示指定也可以使用默认的default</p>
</blockquote>

<p>接下来卡看Eureka是如何实现这些功能的。
平时使用时server只需要一个@EnableEurekaServer的注解就可以开启Eureka服务，client只需要一个@EnableEurekaClient的注解就可以开启Eureka客户端。</p>

<p>@EnableEurekaServer的注解会导入一个EurekaServerMarkerConfiguration配置类，这个类主要是生成一个Marker类作为springboot自动加载配置的标记。主要配置的导入、初始化是在EurekaServerAutoConfiguration类中。（@ConditionalOnBean({Marker.class})）</p>

<h2 id="实现健康检查接口">实现健康检查接口</h2>
<p>EurekaServerAutoConfiguration类中有一个healthCheckHandler的bean，这个bean实现了EurekaHealthCheckHandler接口，这个接口只有一个方法，就是healthCheck()方法，这个方法返回一个HealthCheckStatus对象，这个对象中有一个boolean类型的isHealthy属性，这个属性表示服务是否健康。</p>
<ol>
  <li>打开健康检查
    <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">eureka</span><span class="pi">:</span>
  <span class="na">client</span><span class="pi">:</span>
<span class="err"> </span><span class="na">healthcheck</span><span class="pi">:</span>
   <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div>    </div>
  </li>
  <li>实现com.netflix.appinfo.HealthCheckHandler接口</li>
</ol>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[记录Eureka的设计、实现和应用]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/welcome-to-jekyll/" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2025-03-10T23:00:36+08:00</published><updated>2025-03-10T23:00:36+08:00</updated><id>http://localhost:4000/jekyll/update/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/welcome-to-jekyll/"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle <span class="nb">install
</span>bundle <span class="nb">exec </span>jekyll serve
</code></pre></div></div>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[test excerptexcerptexcerpt]]></summary></entry><entry><title type="html">Maven手册</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/JVM/" rel="alternate" type="text/html" title="Maven手册" /><published>2025-03-10T23:00:36+08:00</published><updated>2025-03-10T23:00:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/JVM</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/JVM/"><![CDATA[<p>jps -l java线程号</p>

<p>jstack 123 打印给定Java进程的内部线程及其堆栈。</p>

<p>javac Test.java 将文件编译成class文件</p>

<p>javap -c -s -v -l ‘Test.class’ 查看编译后的class文件</p>

<p>jstack <code class="language-plaintext highlighter-rouge">jps | grep Main | awk '{print $1}'</code></p>

<p>jmap</p>

<p>jconsole</p>

<h2 id="jvm参数">JVM参数</h2>

<p><a href="https:/cloud.tencent.com/developer/article/2235751?areaSource=102001.10&amp;traceId=rW4tiDs6tKw80LeqYB2wH">https://cloud.tencent.com/developer/article/2235751?areaSource=102001.10&amp;traceId=rW4tiDs6tKw80LeqYB2wH</a></p>

<p>-Xms256m JVM初始内存</p>

<p>-Xmx256m 最大堆大小</p>

<p>-Xmn128m 年轻代大小</p>

<h2 id="idea中配置jvm参数">idea中配置JVM参数</h2>

<p><img src="https:/www.cnblogs.com/shoshana-kong/p/14930258.html" alt="" /></p>

<p>JConsole远程连接</p>

<p><a href="https:/blog.csdn.net/qq407995680/article/details/133922086">https://blog.csdn.net/qq407995680/article/details/133922086</a></p>

<h2 id="jstack输出">Jstack输出</h2>

<p>“DestroyJavaVM” #24 prio=5 os_prio=0 tid=0x0000025bb88dc000 nid=0x374 waiting on condition [0x0000000000000000]</p>

<p>java.lang.Thread.State: RUNNABLE</p>

<p>“Thread-9” #23 prio=5 os_prio=0 tid=0x0000025bb88de000 nid=0x2284 waiting on condition [0x000000ef914ff000]</p>

<p>java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    at java.lang.Thread.sleep(java.base@9.0.4/Native Method)

    at java.lang.Thread.sleep(java.base@9.0.4/Thread.java:340)

    at java.util.concurrent.TimeUnit.sleep(java.base@9.0.4/TimeUnit.java:401)

    at thread.SimpleDeamon.run(SimpleDeamon.java:16)

    at java.lang.Thread.run(java.base@9.0.4/Thread.java:844)
</code></pre></div></div>

<ol>
  <li>
    <p><strong>线程名称和编号</strong></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">"Thread-0"</code>：这是线程的名称。</li>
      <li><code class="language-plaintext highlighter-rouge">#10</code>：这是线程在 JVM 中的唯一编号。</li>
    </ul>
  </li>
  <li>
    <p><strong>优先级</strong></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">prio=5</code>：这是线程在 JVM 中的优先级。优先级范围通常是 1 到 10，5 是默认值。</li>
      <li><code class="language-plaintext highlighter-rouge">os_prio=0</code>：这是操作系统层面的线程优先级。不同的操作系统可能有不同的优先级范围和默认值。</li>
    </ul>
  </li>
  <li>
    <p><strong>线程 ID 和 Native ID</strong></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">tid=0x0000025bb867d800</code>：这是线程的 JVM 内部 ID（线程标识符）。</li>
      <li><code class="language-plaintext highlighter-rouge">nid=0x1098</code>：这是线程的本地操作系统 ID（Native ID）。</li>
    </ul>
  </li>
  <li>
    <p><strong>线程状态</strong></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">waiting on condition</code>：这是线程的状态。表示该线程正在等待某个条件的发生，通常是在调用 <code class="language-plaintext highlighter-rouge">wait()</code> 方法或进入 <code class="language-plaintext highlighter-rouge">Thread.sleep()</code> 状态时。</li>
    </ul>
  </li>
  <li>
    <p><strong>线程栈地址</strong></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">[0x000000ef913fe000]</code>：这是线程的栈地址，用于标识该线程的栈内存区域。</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[Maven手册]]></summary></entry><entry><title type="html">Java线程</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/%E7%BA%BF%E7%A8%8B/" rel="alternate" type="text/html" title="Java线程" /><published>2025-03-10T23:00:36+08:00</published><updated>2025-03-10T23:00:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/%E7%BA%BF%E7%A8%8B</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/%E7%BA%BF%E7%A8%8B/"><![CDATA[<h2 id="书籍推荐">书籍推荐</h2>

<p>《Javav并发编程之美》：偏向基础，讲解各种线程相关概念和使用，源码和实现</p>

<p>《Java并发编程实战》：偏向应用后的注意，部分场景比较难理解</p>

<p>《实战Java高并发程序设计》</p>

<h2 id="1什么是线程">1.什么是线程</h2>

<p>执行程序的最小单位，相当于一个任务</p>

<h2 id="2线程的状态">2.线程的状态</h2>

<p>NEW<br />
RUNNABLE<br />
BLOCKED<br />
WAITING<br />
TIMED_WAITING<br />
TERMINATED</p>

<p><img src="/assets/article/1957e8424a9.png" alt="" /></p>

<h2 id="3实现线程的方法">3.实现线程的方法</h2>

<p>继承Thread类，实现Runable接口，实现Callable接口</p>

<h2 id="4线程同步和线程安全">4.线程同步和线程安全</h2>

<p>线程同步是保证线程安全的手段。</p>

<p>线程安全是指在多线程情况下读取或写入共享变量不会发生超出预期的情况。由于具有静态条件的共享变量在多线程访问时容易出现意料之外的情况，需要线程同步措施保证线程安全。</p>

<h2 id="5线程同步的方式有哪些">5.线程同步的方式有哪些</h2>

<ul>
  <li>使用volatile修饰变量，但只能保证可见性</li>
  <li>使用锁，保证可见性和原子性</li>
  <li>使用原子类atomic,使用底层的CAS保证可见性和原子性</li>
  <li>使用线程池或executor</li>
  <li>使用ThreadLocal</li>
  <li>使用线程安全的容器</li>
  <li>使用栈安全的手段(对数据进行深拷贝，存储影响大)</li>
</ul>

<h2 id="6原子性可见性有序性">6.原子性，可见性，有序性</h2>

<p>原子性：要么同时发生要么同时失败；</p>

<p>可见性：共享变量的修改对其他线程可见，一个线程修改共享变量时没有将指刷入主内存时，其他线程阻塞</p>

<p>有序性：jvm会对无相互依赖的代码指令进行重排序，时序性指按照确定的顺序执行</p>

<p>Happen-Before:</p>

<p>程序顺序原则：一个线程内保证语义的串行性<br />
volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性<br />
锁规则：解锁（unlock）必然发生在随后的加锁（lock）前<br />
传递性：A先于B，B先于C，那么A必然先于C<br />
线程的start()方法先于它的每一个动作<br />
线程的所有操作先于线程的终结（Thread.join()）<br />
线程的中断（interrupt()）先于被中断线程的代码<br />
对象的构造函数执行、结束先于finalize()方法</p>

<h2 id="7锁的概念">7.锁的概念</h2>

<p>乐观锁和悲观锁</p>

<p>公平锁和非公平锁</p>

<p>独占锁和共享锁</p>

<p>可重入锁</p>

<p>自旋锁</p>

<h2 id="8object的线程相关方法">8.Object的线程相关方法</h2>

<p>wait() 释放锁等待,需要注意需要先获取到锁才能使用</p>

<p>notify() 随机唤醒等待队列中的一个对象</p>

<p>ntifyAll()唤醒等待队列中全部的对象</p>

<h2 id="9thread相关方法">9.Thread相关方法</h2>

<p>interrupt() 设置中断标志位，但是不会中断线程</p>

<p>suspend() 废弃</p>

<p>resume() 废弃</p>

<p>sleep() 不释放锁</p>

<p>join() 等待线程结束  join()的本质是让调用线程wait()在当前线程对象实例上</p>

<p>yiled() 让出线程</p>

<h2 id="10reentrantlock和synchronized">10.ReentrantLock和synchronized</h2>

<p>synchronized是以非公平的ReentrantLock实现的</p>

<p>ReentrantLock默认是非公平的</p>

<p>通过AbstractQueuedSynchronizer实现</p>

<p>其中主要通过等待链表、volatile修饰的变量、LockSupport的park()和unpark()</p>

<p>synchronized的几种用法：</p>

<ol>
  <li>指定加锁对象</li>
  <li>修饰方法 以当前实例作为锁</li>
  <li>修饰静态方法  以class作为锁</li>
</ol>

<p>10.1synchronized中锁的状态变化</p>

<h2 id="11书">11.书</h2>

<h3 id="编程之美">编程之美</h3>

<p>在表中添加 version 字段来实现乐观锁</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">int</span> <span class="k">count</span> <span class="o">=</span> <span class="k">update</span><span class="p">(</span><span class="nv">"update table1 set name=#{name},age=#{age},version=${versi
 on}+1 where id =#{id} and version=#{version}"</span><span class="p">,</span><span class="n">entry</span><span class="p">);</span>

</code></pre></div></div>

<p>自旋锁jvm参数设置</p>

<p>自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，<br />
它不马上阻塞自己，在不放弃 CPU 使用权的情况下，多次尝试获取（默认次数是 10，可<br />
以使用 -XX:PreBlockSpinsh 参数设置该值）</p>

<h3 id="实战java">实战Java</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RuntimeException</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Error</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">afterExecute</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">thrown</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="12框架中使用多线程的情况">12.框架中使用多线程的情况</h2>

<h3 id="121-springbatch">12.1 SpringBatch</h3>

<h3 id="122-mybatis">12.2 MyBatis</h3>

<h3 id="123-spring">12.3 Spring</h3>

<h2 id="13etc">13.ETC</h2>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jstack <span class="sb">`</span>jps | <span class="nb">grep </span>IntLock | <span class="nb">awk</span> <span class="s1">'{print $1}'</span><span class="sb">`</span>
</code></pre></div></div>

<h2 id="14condtion">14.Condtion</h2>

<p>await()方法会使当前线程等待，同时释放当前锁</p>

<p>awaitUninterruptibly()方法与await()方法基本相同，但是它并不会在等待过程中响应中断</p>

<p>singal() 方 法 用 于 唤 醒 一 个 在 等 待 中 的 线 程</p>

<p>singalAll() 方 法 会 唤 醒 所 有 在 等 待 中 的 线 程</p>

<h2 id="15-信号量semaphore">15. 信号量（Semaphore）</h2>

<h2 id="16读写锁readwritelock">16.读写锁(ReadWriteLock)</h2>

<p><img src="/assets/article/18ebd96f5f9.png" alt="" /></p>

<h2 id="17倒计时器countdownlatch">17.倒计时器(CountDownLatch)</h2>

<h2 id="18循环栅栏cyclicbarrier">18.循环栅栏(CyclicBarrier)</h2>

<h2 id="19locksupport">19.LockSupport</h2>

<h2 id="20线程安全的容器">20.线程安全的容器</h2>

<p>ConcurrentHashMap：这是一个高效的并发HashMap。你可以理解为一个线程安全的HashMap。<br />
CopyOnWriteArrayList ： 这 是 一 个 List ， 从 名 字 看 就 是 和ArrayList是一族的。在读多写少的场合，这个List的性能非常好，远远好于Vector。<br />
ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的LinkedList。<br />
BlockingQueue：这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。<br />
ConcurrentSkipListMap：跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。</p>

<p>CopyOnWriteArrayList类对它来说，读取是完全不用加锁的，并且更好的消息是：写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待</p>

<h2 id="21线程池">21.线程池</h2>

<p>减少创建和销毁线程的开销</p>

<p>Executors的实现只是对ThreaPoolExecutor的封装</p>

<h3 id="211核心参数">21.1核心参数</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span>
 <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span>
 <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span>
 <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span>
 <span class="nc">BlockingQueue</span><span class="err">＜</span><span class="nc">Runnable</span><span class="err">＞</span> <span class="n">workQueue</span><span class="o">,</span>
 <span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span>
 <span class="nc">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">)</span>
</code></pre></div></div>

<p>corePoolSize：指定了线程池中的线程数量。<br />
maximumPoolSize：指定了线程池中的最大线程数量。<br />
keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间。即，超过corePoolSize   的空闲线程，在多长时间内，会被销毁。<br />
unit：keepAliveTime的单位。<br />
workQueue：任务队列，被提交但尚未被执行的任务。<br />
threadFactory：线程工厂，用于创建线程，一般用默认的即可。<br />
handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</p>

<h3 id="212拒绝策略">21.2拒绝策略</h3>

<p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。<br />
CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。<br />
DiscardOledestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。<br />
DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。</p>

<p><strong>实现自己的拒绝策略</strong></p>

<p><strong>扩展RejectedExecutionHandler接口</strong></p>

<p>21.3</p>

<h2 id="22forkjoin框架">22.Fork/Join框架</h2>

<p><img src="/assets/article/18ebe6563da.png" alt="" /></p>

<h2 id="23提高锁的性能">23.提高锁的性能</h2>

<ol>
  <li>减少锁的持有时间，运行时间长的方法能否避免</li>
  <li>减小锁的粒度，缩小锁定的范围，map分小map,同步代码块减小</li>
  <li>读写分离锁替换独占锁</li>
  <li>锁分离</li>
  <li>锁粗化，减少对锁的获取</li>
</ol>

<h2 id="锁优化">锁优化</h2>

<h2 id="24threadlocal">24.ThreadLocal</h2>

<h2 id="25cas">25.CAS</h2>

<p>它包含三个参数CAS(V,E,N)。V表示要更新的变量，E表示预期值，N表示新值。</p>

<p>AtomicInteger</p>

<p>AtomicReference</p>

<p>AtomicStampedReference</p>

<p>AtomicIntegerArray</p>

<p>SynchronousQueue</p>

<h2 id="26unsafe类">26.UnSafe类</h2>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[Java线程从入门到精通]]></summary></entry><entry><title type="html">几种在Spring启动的时执行代码的方法</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/Spring%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E6%89%A7%E8%A1%8C/" rel="alternate" type="text/html" title="几种在Spring启动的时执行代码的方法" /><published>2025-03-10T23:00:36+08:00</published><updated>2025-03-10T23:00:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/Spring%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E6%89%A7%E8%A1%8C</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/Spring%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E6%89%A7%E8%A1%8C/"><![CDATA[<h1 id="几种在spring启动的时执行代码的方法">几种在Spring启动的时执行代码的方法</h1>

<ol>
  <li>spring boot application本质就是main方法可以在main方法中执行一些初始化的方法。此时Bean都没有创建和注入涉及到Bean的方法无法使用</li>
  <li>使用<code class="language-plaintext highlighter-rouge">@PostConstruct</code>注解在Bean注入之后执行对应的一些init方法</li>
  <li>实现<code class="language-plaintext highlighter-rouge">CommandLineRunner</code>接口</li>
  <li>实现 SmartInitializingSingleton</li>
  <li>实现ApplicationListener<ContextRefreshedEvent></ContextRefreshedEvent></li>
  <li>实现LifecycleProcessor</li>
</ol>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[几种在Spring启动的时执行代码的方法]]></summary></entry><entry><title type="html">SpringBoot</title><link href="http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBoot/" rel="alternate" type="text/html" title="SpringBoot" /><published>2025-03-10T23:00:36+08:00</published><updated>2025-03-10T23:00:36+08:00</updated><id>http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBoot</id><content type="html" xml:base="http://localhost:4000/%E5%90%8E%E7%AB%AF/SpringBoot/"><![CDATA[<p>约定大于配置：</p>

<p>之前的spring项目会存在大量的xml配置，springboot通过内置的默认配置减少了各类jar包的配置情况，只需要更改需要配置的参数即可。</p>

<p>spring-boot-autoconfigure中有大量的配置类</p>

<p>spring boot的内置tomcat在spring-boot-starter-tomcat中</p>

<p>java报错：类文件具有错误的版本 61.0，应为 52.0 请删除该文件或确保该文件位于正确的类路径子目录中。</p>

<p>原因：SpringBoot使用了3.0或者3.0以上，因为Spring官方发布从Spring6以及SprinBoot3.0开始最低支持JDK17</p>

<p>解决: 将版本降低到2.几就行</p>

<h2 id="spring-boot配置">Spring Boot配置</h2>

<p>Spring Boot在auto-configuration中会包含各个组件的默认配置类比如kafa等。</p>

<p><code class="language-plaintext highlighter-rouge">spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaAutoConfiguration.java</code></p>

<p><code class="language-plaintext highlighter-rouge">spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java</code></p>

<h2 id="spring-boot创建自己的stater">Spring Boot创建自己的stater</h2>

<h2 id="spring-boot启动流程">Spring Boot启动流程</h2>

<h2 id="spring-请求流程">Spring 请求流程</h2>

<p>DispatcherServlet–&gt;RequestMappingHandlerMapping-&gt;DispatcherServlet</p>

<p>java.lang.NullPointerException: null</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>at com.easyassetmanagement.asset.service.SubscriptionService.submitOrder(SubscriptionService.java:32) ~[classes/:na]

at com.easyassetmanagement.asset.controller.SubscriptionController.submitForm(SubscriptionController.java:21) ~[classes/:na]

at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]

at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]

at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]

at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]

at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) ~[spring-web-5.3.24.jar:5.3.24]

at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150) ~[spring-web-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1071) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:964) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.24.jar:5.3.24]

at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.3.24.jar:5.3.24]

at javax.servlet.http.HttpServlet.service(HttpServlet.java:696) ~[tomcat-embed-core-9.0.69.jar:4.0.FR]

at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.24.jar:5.3.24]

at javax.servlet.http.HttpServlet.service(HttpServlet.java:779) ~[tomcat-embed-core-9.0.69.jar:4.0.FR]

at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.69.jar:9.0.69]

at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.24.jar:5.3.24]

at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.24.jar:5.3.24]

at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.3.24.jar:5.3.24]

at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.24.jar:5.3.24]

at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.3.24.jar:5.3.24]

at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.24.jar:5.3.24]

at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:177) ~[tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:891) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1784) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) [tomcat-embed-core-9.0.69.jar:9.0.69]

at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.69.jar:9.0.69]

at java.base/java.lang.Thread.run(Thread.java:844) [na:na]
</code></pre></div></div>]]></content><author><name></name></author><category term="后端" /><summary type="html"><![CDATA[SpringBoot笔记]]></summary></entry></feed>